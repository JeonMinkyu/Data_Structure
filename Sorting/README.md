## Bubble Sort

버블 정렬 함수는 인접한 2개의 값을 비교하여 크기가 순서대로 되어있지 않으면 서로 교환하며 정렬합니다. 리스트 왼쪽 끝부터 시작하여 오른쪽 끝까지 진행되며 오름차순으로 정렬할때 순환,교환 과정이 한번 완료되면 가장 큰 데이터가 리스트의 오른쪽 끝으로 이동합니다. 이 과정이 전체 숫자가 정렬될때까지 반복됩니다. 성능은 데이터 수가 n개일때 비교의 횟수가 (n-1)+(n-2)+...+2+1로서 빅오 표기법으로 O(n^2)입니다.



## Merge Sort

다음은 조금 복잡하지만 효율적인 정렬 알고리즘으로 merge 정렬이 있습니다.

하나의 리스트를 2개의 균등한 크기로 분할하고 분할된 부분 리스트들을 정렬한 다음, 두 개의 정렬된 부분을 비교해가며 리스트를 합합니다. 실제 정렬이 이루어지는 시점은 2개의 리스트를 합병하는 단계이며 2개의 리스트 요소들을 처음부터 하나씩 비교하여 두 개의 리스트의 요소중 더 작은 요소를 새로운 리스트로 채워넣습니다. 이 단계를 둘 중 하나가 정렬이 끝날때까지 반복합니다.

merge함수는 마지막에 두 개의 list를 서로 합쳐주는 기능을 하며  mergesort는 재귀적표현으로 구현합니다.

성능을 보면 데이터의 개수n이 반으로 나뉘며 구간별로 정렬이 이루어지므로 부분배열의 크기는 2^(k) ->2^(k-1) -> 2^(k-2)...->2^(0)이 되어 log(2)n으로 표현이 되며 하나의 합병 단계에서 최대 n번의 비교연산이 필요합니다. 따라서 총 비교연산은 최대 n*log(2)n만큼 필요하고 빅오표기법으로 O(n*log(2)n)로 표현이 가능합니다



## Radix Sort

기수정렬은 각 가장 낮은 자리수부터 기준으로하여 각각의 해당하는 bucket에 넣었다가 다시 꺼내어 정렬을 합니다 . 이때 버켓은 10진수의 경우 0~9까지 10개의 bucket이 필요하며 크기를 비교하기위한 비교연산이 따로 필요가 없습니다.

성능은 버킷으로의 삽입과 추출의 빈도수를 대상으로 결정되며 정렬 대상의 수가 n이고 모든 정렬 대상의 길이가 l일때 O(ln)=O(n)으로 표현이 가능합니다.

3가지 정렬 중에 시간복잡도로만 보면 기수정렬이 가장 효율적인것을 알 수 있습니다.

sorted함수는 배열내의 원소들을 출력하는 함수입니다. 