#include <stdio.h>
#include <stdlib.h>

#define MAZE_MAX 10
//===================stack data structure======================
typedef struct node__ {
	int x;
	int y;
	struct node__* next;
}node;

typedef struct stack__ {
	node* top;
}stack;

node* new_node(int x, int y) {
	node* tmp = (node*)malloc(sizeof(node));
	tmp->x = x;
	tmp->y = y;
	tmp->next = NULL;

	return tmp;
}

void push(stack* s, int x, int y) {
	node* tmp = new_node(x, y);

	tmp->next = s->top;
	s->top = tmp;
}

void pop(stack* s, int* x, int* y) {
	if (s->top == NULL)
		printf("pop error");
	else {
		*x = s->top->x;
		*y = s->top->y;
		node* tmp = s->top;
		s->top = s->top->next;
		free(tmp);
	}
}

stack* create_stack() {
	stack *tmp = (stack*)malloc(sizeof(stack));
	tmp->top = NULL;

	return tmp;
}
//===================stack data structure end===================
//===================graph data structure =====================

typedef struct vertex_ {
	struct vertex_* next;
	int x, y;
	struct arcNode_* degree;
}vertex;

typedef struct arcNode_ {
	int x, y;
	int arc;
	struct arcNode_* nextArc;
}arcNode;

typedef struct graph_ {
	struct vertex_* start;
}graph;

vertex* new_vertex(int x, int y) {
	vertex* tmp = (vertex*)malloc(sizeof(vertex));
	tmp->degree = NULL;
	tmp->next = NULL;
	tmp->x = x;
	tmp->y = y;

	return tmp;
}

arcNode* new_arcNode(int arc, int x, int y) {
	arcNode* tmp = (arcNode*)malloc(sizeof(arcNode));
	tmp->nextArc = NULL;
	tmp->x = x;
	tmp->y = y;
	tmp->arc = arc;

	return tmp;
}

graph* create_graph() {
	graph* g = (graph*)malloc(sizeof(graph));
	g->start = NULL;
	return g;	
}

void insert_vertex(graph* g, int x, int y) {
	vertex* tmp = new_vertex(x, y);
	vertex* check;

	if (g->start == NULL) {
		g->start = tmp;
	}
	else {
		check = g->start;
		while (check->next != NULL) {
			check = check->next;
		}
		check->next = tmp;
	}
}
//add vertex to graph

void insert_edge(vertex* v, int arc, int x, int y) {
	arcNode* tmp = new_arcNode(arc, x, y);
	arcNode* check;

	if (v->degree == NULL) {
		v->degree = tmp;
	}
	else {
		check = v->degree;
		while (check->nextArc != NULL) {
			check = check->nextArc;
		}
		check->nextArc = tmp;
	}
}
//add edge to vertex

/*void print_vertex(graph* g) {
	vertex* tmp = g->start;

	printf("%d, %d\n", tmp->x, tmp->y);
	while (tmp->next != NULL) {
		tmp = tmp->next;
		printf("%d, %d\n", tmp->x, tmp->y);
	}
}

void print_edge(vertex* v) {
	arcNode* tmp = v->degree;

	printf("%d, %d %d\n", tmp->x, tmp->y, tmp->arc);
	while (tmp->nextArc != NULL) {
		tmp = tmp->nextArc;
		printf("%d, %d %d\n", tmp->x, tmp->y, tmp->arc);
	}
	printf("\n");
}*/
//아래 함수가 더 나으므로 지워둠

int print_arcNode(vertex *v) {
	arcNode *tmp = v->degree;

	if (tmp == NULL) return -1;

	printf("(%d, %d)  %d  ", tmp->x, tmp->y, tmp->arc);
	while (tmp->nextArc != NULL) {

		tmp = tmp->nextArc;
		printf("(%d, %d)  %d  ", tmp->x, tmp->y, tmp->arc);

	}

	printf("\n");

	return 0;

}

void print_graph(graph *g) {
	vertex* tmp = g->start;

	printf("(%d, %d)     ", tmp->x, tmp->y);
	print_arcNode(tmp);
	while (tmp->next != NULL) {
		tmp = tmp->next;
		printf("(%d, %d)     ", tmp->x, tmp->y);

		if (print_arcNode(tmp) == -1) printf("\n");

	}

}
//===========================graph data structure end====================

void add_edge(vertex* v, char maze[MAZE_MAX][MAZE_MAX]) {
	stack* s = create_stack();
	char copy[MAZE_MAX][MAZE_MAX];
	int x, y;
	int i, j, k;
	int count;	//갈림길의 갯수를 판별하는 변수
	int length; // vertex간의 거리를 재는 변수

	for (i = 0; i < MAZE_MAX; i++) {
		for (j = 0; j < MAZE_MAX; j++) {
			copy[i][j] = maze[i][j];
		}
	}

	copy[v->y][v->x] = 'e';

	if (copy[v->y - 1][v->x] == '0')
		push(s, v->y - 1, v->x);
	if (copy[v->y + 1][v->x] == '0')
		push(s, v->y + 1, v->x);
	if (copy[v->y][v->x - 1] == '0')
		push(s, v->y, v->x - 1);
	if (copy[v->y][v->x + 1] == '0')
		push(s, v->y, v->x + 1);
	//v의 갈림길의 시작점들을 스택에 push

	while (s->top != NULL) {
		pop(s, &y, &x);	//그 중에 하나를 pop 하고
		length = 0;

		while (1) {	//다음 vertex까지의 길을 찾아간다
			copy[y][x] = 'e';
			count = 0;

			if (y - 1 >= 0) {
				if (copy[y - 1][x] == '0') {
					push(s, y - 1, x);
					count++;
				}	
			}
			if (y + 1 < MAZE_MAX) {
				if (copy[y + 1][x] == '0') {
					push(s, y + 1, x);
					count++;
				}
			}
			if (x - 1 >= 0) {
				if (copy[y][x - 1] == '0') {
					push(s, y, x - 1);
					count++;
				}
			}
			if (x + 1 < MAZE_MAX) {
				if (copy[y][x + 1] == '0') {
					push(s, y, x + 1);
					count++;
				}
			}
			length++;

			if (count > 1 || count == 0) {
				insert_edge(v, length, x, y);

				for (k = 0; k < count; k++) {
					pop(s, &y, &x);
				}

				break;
			}	//vertex를 찾았으면 그래프에 추가하고 다음 갈림길로 간다
			else
				pop(s, &y, &x);

		}
	}
}

int main(void) {

	char maze[MAZE_MAX][MAZE_MAX] = {
	{ '1', '1', '1', '1', '1', '1', '1', '1', '1', '1' },
	{ '0', '0', '0', '0', '1', '1', '0', '0', '0', '1' },
	{ '1', '0', '1', '0', '1', '0', '0', '1', '0', '1' },
	{ '1', '0', '1', '1', '0', '0', '1', '1', '0', '1' },
	{ '1', '0', '0', '0', '0', '1', '1', '1', '0', '1' },
	{ '1', '0', '1', '1', '0', '0', '1', '1', '0', '1' },
	{ '1', '0', '0', '1', '1', '0', '1', '1', '0', '1' },
	{ '1', '1', '0', '0', '1', '0', '0', '0', '0', '1' },
	{ '1', '1', '1', '0', '0', '0', '1', '1', '0', '0' },
	{ '1', '1', '1', '1', '1', '1', '1', '1', '1', '1' },
	};

	int countZero;
	int i, j;
	graph* g = create_graph();
	vertex* tmp;	

	//maze[j][i]; i = x, j = y;
	for (i = 0; i < MAZE_MAX; i++) {
		for (j = 0; j < MAZE_MAX; j++) {
			if (i == 0 || j == 0) {
				if (maze[j][i] == '0') 
					insert_vertex(g, i, j);
			}
			//start point, end point
			else {
				if (maze[j][i] == '0') {
					countZero = 0;
					if (maze[j - 1][i] == '0')
						countZero++;
					if (maze[j][i - 1] == '0')
						countZero++;
					if (maze[j + 1][i] == '0')
						countZero++;
					if (maze[j][i + 1] == '0')
						countZero++;

					if (countZero > 2 || countZero == 1) {
						insert_vertex(g, i, j);
					}
				}
			}
			//check 4-direction
		}
	}
	//처음 vertex들을 그래프에 추가함
	
	//print_vertex(g);

	tmp = g->start;

	add_edge(tmp, maze);
	while (tmp->next != NULL) {
		tmp = tmp->next;
		add_edge(tmp, maze);
	}
	//각 vertex를 돌면서 연결된 arcNode들을 추가함

	/*tmp = g->start;

	print_edge(tmp);
	while (tmp->next != NULL) {
		tmp = tmp->next;
		print_edge(tmp);
	}*/

	print_graph(g);

	//print는 vertex edge 합쳐서 출력하도록 바꿀 수 있음
	//다른 분이 올려주셨음

	system("pause");
	return 0;
}